\documentclass[11pt,a4paper]{report}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                 %%
%%    Header file for the Phi-S-X Series                           %%
%%                                                                 %%
%%    german version header_gm.tex is derived from header.tex      %%
%%    by uncommenting the line ``\setboolean{german}{true}'' below %%
%%                                                                 %%
%%    Never edit the german version! all changes must be done      %%
%%    in the english version header.tex                            %%
%%                                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{../header}
\hypersetup{pdftitle=paw_brillouin}
\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{3.5cm}
{\huge \textbf{Coding standards for the CP-PAW code}}\\
\vspace{0.5cm}
{\large Peter E. Bl\"ochl}
\vspace{0.5cm} 
\end{center}

\vfill
\begin{center}
Copyright Peter E. Bl\"ochl; Sept.2, 2013-\today\\
{\small
Institute of Theoretical Physics;
Clausthal University of Technology;\\ 
D-38678 Clausthal Zellerfeld; Germany;\\
http://www.pt.tu-clausthal.de/atp/}
\end{center}
\end{titlepage}
\noindent            
\tableofcontents
%====================================================================
\chapter{Coding Standards of the PAW project}
%====================================================================
Coding and maintainance of large code projects are made more
efficient, if one is guided by recurring patterns. Therefore, a style
guide for coding projects is adviseable.

The style guide is, as the name says, a guide and not a law. Thus it
is permitted to deviate from it if there is good reason.

While such rules appear to the beginnner as administrative overhead,
they pay off in larger code projects.

Some of the principles have been inspired by the GNU Coding Standards\\
\url{http://www.gnu.org/prep/standards}.
%
%====================================================================
\section{SHELL scripting}
%====================================================================
\cite{1}
\begin{itemize}
\item specify the \verb|SHELL| variable: start the script with
  \verb|#!/bin/bash| as first line. You may use another shell instead
  of bash, but bash is preferred.
%
\item Define a variable named \verb|USAGE| describing the function of
  the script and its options. Example:
\begin{verbatim}
export $USAGE="Usage of $0\n"
USAGE="$USAGE description \n"
\end{verbatim}
(\verb|\$0| expands into the name of the script.). Insert the
description in place of the string description. Several lines can be
added similar to the second one given here.

%
\item pass arguments as variables to options. You may allow for one
  special argument that is provided behind the options. Analyze
  options with getopts. Example
\begin{verbatim}
while getopts :h0b:p: OPT ; do
  case $OPT in
    x)   # executable
      EXCTBLE=$OPTARG
      shift
      ;; 
    b)   # directory holding paw executables
      PAWXDIR=$OPTARG  
      shift
      ;; 
    p)   # project name
      PROJECT=$OPTARG
      echo argument projectname=${NAME}
      shift
      ;;
    0)   # dry run only
      DRYRUN=yes
      echo option dry-run=${DRYRUN}
      shift
      ;;
    h)   # help
      echo -e $USAGE
      exit 1
      ;;
    \?)   # unknown option (placed into OPTARG, if OPTSTRING starts with :)
      echo "error in $0" >&2
      echo "invalid option -$OPTARG" >&2
      echo "retrieve argument list with:" >&2
      echo "$0 -h" >&2
      exit 1
      ;;
    :)    # no argument passed to option requiring one
      echo "error in $0" >&2
      echo "option -$OPTARG requires an additional argument" >&2
      exit 1
      ;;  esac
  esac
done
shift $(($OPTIND - 1)) # shift so that following arguments are $1, $2, etc.
if [ -z $1 ] ; then echo ``error in $0: missing argument'' >&2
ARG=$1
\end{verbatim}
% 
\item check if all mandatory arguments have been passed.
%
\item for every error, that has been captured, exit with a non-zero
  return code, i.e. by \verb|exit 1|, and issue an error message to
  ``error out''=\&2.
\begin{verbatim}
echo "error in $0: message" >&2
exit 1
\end{verbatim}
%
\item finish the script with \verb|exit 0|
\end{itemize}

%====================================================================
\subsection{List of recommended option id's}
%====================================================================
The following list shall not be used, except with the meaning
described here. Some of these choices are inspired by
\url{http://www.faqs.org/docs/artu/ch10s05.html}.
\begin{description}
\item[a] All.
\item[c] name of the control file
\item[f] input file (other than a control file)
\item[l] list
\item[o] output file
\item[p] root name of the paw project 
\item[e] executable
\item[b] directory holding the executables (to select a specific paw
  distribution)
\item[0] dry run
\item[v] verbose
\item[V] version
\item[q] quiet
\item[h] issue help message
\end{description}

%====================================================================
\subsection{Brief description of getopts}
%====================================================================
The bash command getopts process the argument list in a standardized
manner and allows for automatized error handling.

The bash command 
\begin{center}
\verb|getopts| \$OPTSTRING OPT
\end{center}
processes an option string OPTSTRING, and returns true or false
depending of whether it encountered a valid option in teh calling
sequence of the calling bash script. It returns the id of the option
as \$OPT and it sets the variable OPTARG with the argument of the
option. In case of an error OPTARG contains the name of the option, if
OPTSTRING starts with a colon ``:''.

The option string is a string of option letters. An option with an
argument is followed by a colon ``:''. An initial ``:'' switches
getopts into the quiet mode, which also changes the error
handling. Therefore capture all errors and work in quiet mode.

\begin{itemize}
\item A double dash ``--'' signifies the end of the options
%
\item Options may be grouped such as \verb|-abc| which is identical to
\verb|-a -b -c|.
%
\item Options may only be single letters or numerals.
%
\item OPTIND is another variable used by getopts and it identifies the
  number of items in the argument list that has been processed by
  getopts. With the command \verb|shift $(($OPTIND - 1))| the first
  item following the option list is \verb|$1|.
\end{itemize}

%====================================================================
\subsection{Default environment}
%====================================================================
\begin{itemize}
\item the current PAW directory can be obtained via
\begin{verbatim}
export PAWXDIR=$(which paw_fast.x); PAWXDIR=${PAWXDIR%paw_fast.x}
\end{verbatim}
%
\item The current directory is captured with
\begin{verbatim}
THISDIR=$(pwd)   # current directory
\end{verbatim}
\end{itemize}

%====================================================================
\subsection{Other shell rules}
%====================================================================
\begin{itemize}
\item Make temporary files:  Check first if the environment variable
  TMPDIR is set and use this one. If it is not set, use /tmp.  Create
  temporary file using mktemp. Check error code of mktemp. Delete the
  file when done.
%
\item do not use non-printing characters nor include them in the
  files. Use tabs only, when the syntax requires it, such as in make.
%
\item indent with two spaces for each level.

\end{itemize}

%====================================================================
\section{Fortran codes}
%====================================================================
\begin{itemize}
\item I start with code at column 7 similar to the ancient fixed file
  format of Fortran. The first few spaces are for code that is written
  for debugging only and that should be removed in the final code.
%
\item Keep lines within 80 characters. \textit{Rationale: Longer lines
  usually break when they are printed, which makes the printout ugly.}
%
\item The general style for subroutines is as follows. (the line with
  the numbers does not belong to the style.)
\begin{verbatim}
12345678901234567890123456789012345678901234567890123456789012345678901234567890
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      Subroutine doing(n,b,c)
!     **************************************************************************
!     **  description of doing here                                           **
!     **************************************************************************
      implicite none
      integer(4),intent(in) :: n
      real(8)   ,intent(in) :: a(n) !comment on variable a here
      real(8)   ,intent(out):: b(n)
!     **************************************************************************
!
!     ==========================================================================
!     == section comment                                                      ==
!     ==========================================================================
!
!     ==minor structuring comment===============================================

!     __explaining comment/remark_______________________________________________

print*,'a ',a   ! statement used for testing 

      return
      end
\end{verbatim}
%
\item modules are not indented to the seventh column but are typed
 starting at the first column.
%
\item Always use \verb|implicit none|. Try to start the names of
  integers with letters, i,j,k,l,m,n, and the name of logical
  variables with t. \textit{Rationale: with ``implicit none'',
    typos become apparent quickly.}
%
\item For all variables in the argument list, declare the intent as
  \verb|intent(in)|, \verb|intent(out)| or \verb|intent(inout)|.
%
\item declare one variable per line. Do note use "DIMENSION", but use
\begin{verbatim}
   real(8)              :: a(n)    ! good
   real(8),dimension(n) :: a       ! bad
\end{verbatim}
\textit{Rationale: Dimensions are declared more efficiently together
  with the variable. The explicit dimension statement takes space away
  that can be used better for comments.}
%
\item Specify the used module variables explicitly using the
  \verb|only| statement. Preferably break the line after each variable
  in the \verb|only|-list, so that a descriptive comment can be added.
\begin{verbatim}
   use xxx_module, only : variable1 & !(n1,n2) first variable
  &                      ,variable2   ! second variable

\end{verbatim}
%
\item Keep the following sequence in the declaration section of the
  code.
  \begin{enumerate}
     \item \verb|use| statements
     \item \verb|implicit none|
     \item Derived type definitions
     \item declarations of variables in the argument list
     \item declare parameters
     \item declare other variables
     \item keep loop variables towards the end of the declaration
       section. 
  \end{enumerate}
%
\item variable and subroutine names shall be as descriptive as
  possible.
%
\item avoid functions in favor of subroutines. \textit{Rationale:
  Functions calls can easily be mistaken as variables. Subroutines
  offer the same functionality as functions, but are more
  explicit. Functions offer two competing ways of returning variables,
  which seems to be a design flaw.}
%
\item define parameters such as as tolerances, maximum iteration
  numbers with the parameter statement in the declaration section of a
  subroutine, and NOT in the code section itself.
%
\item do not introduce size limitations, if they can change. Instead
  allocate arrays dynamically.
%
\item if an error has been detected, let the code stop. Give it a
 sensible error message if possible. If the crash is due to a user
 error, provide info on how to correct it.
%
\item Continuation lines: use a \& both at the end of the continued
 line and at the beginning (column 6) of the continuing line.
%
\item Place a connecting symbol such as an operator ``+'',''*'',
  etc. or separator ``,'', ``//'' on the continued line instead of the
  continuing line. \textit{Rationale: This symbol has only meaning
    with the following element and it looses its meaning when the
    continuing element is removed. Thus it belongs conceptually to the
    latter.}
%
\item write any comments in english.
%
\item write the code so that it can be made uppercase without changing
  its meaning. Thus the value string variable must be uppercase, or it
  must be made lowercase for example using the string object of the
  PAW library. Case conversion can be done with the operators ``+''
  and ``-'' defined in the paw\_strings object of the paw
  code. \textit{Rationale: Fortran is case insensitive. To be
    consistent, case conversion shall not change the meaning of the
    code. Some programmers prefer to type uppercase and others
    lowercase. Case conversion shall therefore be without
    consequence.}
%
\item use descriptive filenames
%
\item add a comment to each "enddo" or "end if", if the loop or if
 statement has been long, such as
\begin{verbatim}
   enddo   ! end of loop over atoms (iat)
\end{verbatim}
%
\item Never use special characters or blanks in a file
  name. \textit{Rationale: These characters cannot be easily
    identified with any editor. Blanks act as separator for shell
    arguments. A blank must escaped with a backslash. Thus files in
    blanks are a common source of error.}
%
\item statements that are inserted for debugging purposes start in
  the first instead of the 7-th column. \textit{Rationale: Statements
    starting in he first column are easily identified and removed, when
    they become obsolete.}

\end{itemize}

%====================================================================
\subsection{Object oriented coding}
%====================================================================
An object is a fortran module holding a set of data and a set of
 subroutines operating on them. (It could be a class in ++)

The main feature of an object is that it exposes only a well defined and
 minimal interface to the outside and hides data and internal
 technicalities from the "user" of the object. 

Data will be exchanged almost exclusively during function calls or
 using explicit interfaces such as
\begin{verbatim}
  subroutine objnm$setr8a(id,len,val)
  use objnm_module, only : this,that
  implicit none
  character(*),intent(in) :: id
  real(8)     ,intent(in) :: val(len)
  if(id.eq.'this') then
    thisdata=val
  else if(id.eq.'that') then
    thatdata=val
  else
    call error$msg('id not recognized')
    call error$chval('id',id)
    call error$r8val('val',val)
    call error$stop('objnm$setr8')
  end
  return
  end
\end{verbatim}
\begin{itemize}
\item For scalar variables the letter ``a'' is dropped from the name and the
variable ``len''. 
%
\item ``R8'' stands for real(8). Other possibilities are ``I4''
  (integer(4)), ``L4'' logical(4), ``C8'' complex(8).
%
\item in addition to the set routines there are analogous get routines.
\end{itemize}

The object modul MUST NEVER be used outside the object!

Each object has a name such as \verb|objnm|. The corresponding object module
has the name \verb|objnm_module|. The subrouitines that may be used
externally, wave names \verb|objnm\$subname|, where the dollar sign
separates the object name from the function name. The dollar sign will
be replaced by a double underscore during compilation. Subroutines
that are to be used only from subroutines of the object, will be named
as \verb|objnm\_subnm|, where the function part is separated by an
underscore from the main part.

%====================================================================
\chapter{Code analysis using Doxygen}
%====================================================================
Doxygen is a free multi-platform code analysis and documentation tool.
Doxygen can be downloaded from \url{www.doxygen.org}.


A description on how to use it can be found in
\url{http://www.msg.chem.iastate.edu/gamess/DoxygenRules.oct10.pdf}


Lines starting with ``!>'' are interpreted as Doxygen comments

Doxygen knows a couple of keywords:
\begin{itemize}
\item @brief: One-sentence description of the subroutine
\item @details: Detailed information about the subroutine
\item @note: special notes for the user
\item @see
\item @warning
\item @todo
\item @bug
\item @param \textit{[dir] argument-name description}: in and output variables. Dir can be ``in'' or ``out''.
\item @author
\item @date \textit{Month,Year, Author's name}: used for Bugfixes
\item \verb|\cite| \textit{label}: refers to latex bibliography
  identifiers specified in \verb|CITE_BIB_FILES|
\end{itemize}

%=================================================================
\subsection{Markdown language}
%=================================================================
%% \begin{itemize}
%% \item Headers: a \# preceeding a text followed by another \# is
%%   interpreted as a level-1 header. Preceeding with two or more
%%   \#-signs leads to level-2 or further headings.
%% %
%% \item bullet lists: Unnumbered lists are created using properly
%%   indented ``-'' signs. NUmbered paragrags are created by numbers
%% %
%% \end{itemize}



%=================================================================
\subsection{Ideas to automatically convert code into doxygen comments}
%=================================================================

\begin{itemize}
\item the PAW comments should follow the rules of the markdown language
\item A comment following an variable specification carrying the
  intent(in),intent(out) or intent(inout) is the variable description
  and is tagged by the @param keyword.
%
\item A subroutine comment is characterized by \verb|!  **| and
  follows the subroutine statement
\begin{itemize}
\item the first sentence goes into @brief
\item the rest, not identified by some other keyword goes into @details
\item note,see,todo,bug is parsed and transformed into Doxygen statements
\item @author is grabbed from the last line of the subroutine comment
\end{itemize}
\end{itemize}


\clearpage
\bibliographystyle{unsrtnat}
\bibliography{../all}
\end{document}  
