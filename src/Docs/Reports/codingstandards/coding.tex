\documentclass[11pt,a4paper]{report}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                 %%
%%    Header file for the Phi-S-X Series                           %%
%%                                                                 %%
%%    german version header_gm.tex is derived from header.tex      %%
%%    by uncommenting the line ``\setboolean{german}{true}'' below %%
%%                                                                 %%
%%    Never edit the german version! all changes must be done      %%
%%    in the english version header.tex                            %%
%%                                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{../header}
\hypersetup{pdftitle=paw_brillouin}
\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{3.5cm}
{\huge \textbf{Coding standards for the CP-PAW code}}\\
\vspace{0.5cm}
{\large Peter E. Bl\"ochl}
\vspace{0.5cm} 
\end{center}

\vfill
\begin{center}
Copyright Peter E. Bl\"ochl; Sept.2, 2013-\today\\
{\small
Institute of Theoretical Physics;
Clausthal University of Technology;\\ 
D-38678 Clausthal Zellerfeld; Germany;\\
http://www.pt.tu-clausthal.de/atp/}
\end{center}
\end{titlepage}
\noindent            
\tableofcontents
%====================================================================
\chapter{Coding Standards of the PAW project}
%====================================================================
%====================================================================
\section{SHELL scripting}
%====================================================================
\cite{1}
\begin{itemize}
\item specify the \verb|SHELL| variable: start the script with
  \verb|#!/bin/bash| as first line. You may use another shell instead
  of bash, but bash is preferred.
%
\item Define a variable named \verb|USAGE| describing the function of
  the script and its options. Example:
\begin{verbatim}
export $USAGE="Usage of $0\n"
USAGE="$USAGE description \n"
\end{verbatim}
(\verb|\$0| expands into the name of the script.). Insert the
description in place of the string description. Several lines can be
added similar to the second one given here.

%
\item pass arguments as variables to options. You may allow for one
  special argument that is provided behind the options. Analyze
  options with getopts. Example
\begin{verbatim}
while getopts :h0b:p: OPT ; do
  case $OPT in
    x)   # executable
      EXCTBLE=$OPTARG
      shift
      ;; 
    b)   # directory holding paw executables
      PAWXDIR=$OPTARG  
      shift
      ;; 
    p)   # project name
      PROJECT=$OPTARG
      echo argument projectname=${NAME}
      shift
      ;;
    0)   # dry run only
      DRYRUN=yes
      echo option dry-run=${DRYRUN}
      shift
      ;;
    h)   # help
      echo -e $USAGE
      exit 1
      ;;
    \?)   # unknown option (placed into OPTARG, if OPTSTRING starts with :)
      echo "error in $0" >&2
      echo "invalid option -$OPTARG" >&2
      echo "retrieve argument list with:" >&2
      echo "$0 -h" >&2
      exit 1
      ;;
    :)    # no argument passed to option requiring one
      echo "error in $0" >&2
      echo "option -$OPTARG requires an additional argument" >&2
      exit 1
      ;;  esac
  esac
done
shift $(($OPTIND - 1)) # shift so that following arguments are $1, $2, etc.
if [ -z $1 ] ; then echo ``error in $0: missing argument'' >&2
ARG=$1
\end{verbatim}
% 
\item check if all mandatory arguments have been passed.
%
\item for every error, that has been captured, exit with a non-zero
  return code, i.e. by \verb|exit 1|, and issue an error message to
  ``error out''=\&2.
\begin{verbatim}
echo "error in $0: message" >&2
exit 1
\end{verbatim}
%
\item finish the script with \verb|exit 0|
\end{itemize}

%====================================================================
\subsection{List of recommended option id's}
%====================================================================
The following list shall not be used, except with the meaning
described here. Some of these choices are inspired by
\url{http://www.faqs.org/docs/artu/ch10s05.html}.
\begin{description}
\item[a] All.
\item[c] name of the control file
\item[f] input file (other than a control file)
\item[l] list
\item[o] output file
\item[p] root name of the paw project 
\item[e] executable
\item[b] directory holding the executables (to select a specific paw
  distribution)
\item[0] dry run
\item[v] verbose
\item[V] version
\item[q] quiet
\item[h] issue help message
\end{description}

%====================================================================
\subsection{Brief description of getopts}
%====================================================================
The bash command getopts process the argument list in a standardized
manner and allows for automatized error handling.

The bash command 
\begin{center}
\verb|getopts| \$OPTSTRING OPT
\end{center}
processes an option string OPTSTRING, and returns true or false
depending of whether it encountered a valid option in teh calling
sequence of the calling bash script. It returns the id of the option
as \$OPT and it sets the variable OPTARG with the argument of the
option. In case of an error OPTARG contains the name of the option, if
OPTSTRING starts with a colon ``:''.

The option string is a string of option letters. An option with an
argument is followed by a colon ``:''. An initial ``:'' switches
getopts into the quiet mode, which also changes the error
handling. Therefore capture all errors and work in quiet mode.

\begin{itemize}
\item A double dash ``--'' signifies the end of the options
%
\item Options may be grouped such as \verb|-abc| which is identical to
\verb|-a -b -c|.
%
\item Options may only be single letters or numerals.
%
\item OPTIND is another variable used by getopts and it identifies the
  number of items in the argument list that has been processed by
  getopts. With the command \verb|shift $(($OPTIND - 1))| the first
  item following the option list is \verb|$1|.
\end{itemize}

%====================================================================
\subsection{Default environment}
%====================================================================
\begin{itemize}
\item the current PAW directory can be obtained via
\begin{verbatim}
export PAWXDIR=$(which paw_fast.x); PAWXDIR=${PAWXDIR%paw_fast.x}
\end{verbatim}
%
\item The current directory is captured with
\begin{verbatim}
THISDIR=$(pwd)   # current directory
\end{verbatim}
\end{itemize}

%====================================================================
\subsection{Other shell rules}
%====================================================================
\begin{itemize}
\item Make temporary files:  Check first if the environment variable
  TMPDIR is set and use this one. If it is not set, use /tmp.  Create
  temporary file using mktemp. Check error code of mktemp. Delete the
  file when done.
%
\item do not use non-printing characters nor include them in the
  files. Use tabs only, when the syntax requires it, such as in make.
%
\item indent with two spaces for each level.

\end{itemize}

%====================================================================
\section{Fortran codes}
%====================================================================
\begin{itemize}
\item I start with code at column 7 similar to the ancient fixed file
  format of Fortran. The first few spaces are for code that is written
  for debugging only and that should be removed in the final code.
%
\item Keep lines within 80 characters. Longer lines usually break when
  they are printed, which makes the printout ugly.
%
\item The general style for subroutines is as follows. (the line with
  the numbers does not belong to the style.)
\begin{verbatim}
12345678901234567890123456789012345678901234567890123456789012345678901234567890
!
!     ...1.........2.........3.........4.........5.........6.........7.........8
      Subroutine doing(n,b,c)
!     **************************************************************************
!     **  description of doing here                                           **
!     **************************************************************************
      implicite none
      integer(4),intent(in) :: n
      real(8)   ,intent(in) :: a(n) !comment on variable a here
      real(8)   ,intent(out):: b(n)
!     **************************************************************************
!
!     ==========================================================================
!     == section comment                                                      ==
!     ==========================================================================
!
!     ==minor structuring comment===============================================

!     __explaining comment/remark_______________________________________________

print*,'a ',a   ! statement used for testing 

      return
      end
\end{verbatim}
%
\item modules are not indented to the seventh column but are typed
 starting at the first column.
%
\item Always use \verb|implicit none|. Try to start the names of integers with
 letters, i,j,k,l,m,n, and the name of logical variables with t.
%
\item declare one variable per line. Do note use "DIMENSION", but use
\begin{verbatim}
   real(8)              :: a(n)   ! good
   real(8),dimension(n) :: a(n)    ! bad
\end{verbatim}
%
\item use variable and subroutine names that are as descriptive as
 possible.
%
\item avoid functions in favor of subroutines
%
\item Define parameters such as as tolerances, maximum iteration
 numbers with the parameter statement in the header section, and NOT
 in the code itself.
%
\item Do not introduce size limitations. Instead allocate arrays
 dynamically.
%
\item if an error has been detected let the code stop. Give it a
 sensible error message if possible. If the crash is due to a user
 error, provide info on how to correct it.
%
\item Continuation lines: use a \& both at the end of the continued
 line and at the beginning (column 6) of the continuing line.
%
\item write any comments in english.
%
\item write the code so that it can be made uppercase without changing
 its meaning. Thus the value string variable must be uppercase, or it
 must be made lowercase for example using the string object of the PAW
 library.
%
\item use descriptive filenames
%
\item add a comment to each "enddo" or "end if", if the loop or if
 statement has been long.
%
\item Never use special characters or blanks in a file name.
\end{itemize}

%====================================================================
\subsection{Object oriented coding}
%====================================================================
An object is a fortran module holding a set of data and a set of
 subroutines operating on them. (It could be a class in ++)

The main feature of an object is that it exposes only a well defined and
 minimal interface to the outside and hides data and internal
 technicalities from the "user" of the object. 

Data will be exchanged almost exclusively during function calls or
 using explicit interfaces such as
\begin{verbatim}
  subroutine objnm$setr8a(id,len,val)
  use objnm_module, only : this,that
  implicit none
  character(*),intent(in) :: id
  real(8)     ,intent(in) :: val(len)
  if(id.eq.'this') then
    thisdata=val
  else if(id.eq.'that') then
    thatdata=val
  else
    call error$msg('id not recognized')
    call error$chval('id',id)
    call error$r8val('val',val)
    call error$stop('objnm$setr8')
  end
  return
  end
\end{verbatim}
\begin{itemize}
\item For scalar variables the letter ``a'' is dropped from the name and the
variable ``len''. 
%
\item ``R8'' stands for real(8). Other possibilities are ``I4''
  (integer(4)), ``L4'' logical(4), ``C8'' complex(8).
%
\item in addition to the set routines there are analogous get routines.
\end{itemize}

The object modul MUST NEVER be used outside the object!

Each object has a name such as \verb|objnm|. The corresponding object module
has the name \verb|objnm_module|. The subrouitines that may be used
externally, wave names \verb|objnm\$subname|, where the dollar sign
separates the object name from the function name. The dollar sign will
be replaced by a double underscore during compilation. Subroutines
that are to be used only from subroutines of the object, will be named
as \verb|objnm\_subnm|, where the function part is separated by an
underscore from the main part.






\clearpage
\bibliographystyle{unsrtnat}
\bibliography{../all}
\end{document}  
